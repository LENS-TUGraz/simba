{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#simba-simulation-framework-for-battery-free-systems","title":"Simba: Simulation Framework for Battery-Free Systems","text":"<p>Simba is an open-source simulation framework that allows to explore and facilitate the design of battery-free systems and is freely available on Github.</p> <p>The design of battery-free systems (i.e., embedded devices powered by energy harvesters) is complex, as these devices cover a huge design space, exhibit non-trivial energy-driven dependencies between their different components, and are typically hard to debug, verify, evaluate, and compare.</p> <p>Simba enables a fast and easy simulation of battery-free devices by integrating different component models and datasets in a single simulation core, and can thus be used for both long-term simulations with real-world traces (i.e., to verify given designs) and short-term simulations with small time granularity (i.e., to explore design options and gain a better understanding of interactions between different components). </p>"},{"location":"#features","title":"Features","text":"<ul> <li>Python-based simulation framework for battery-free devices consisting of an energy harvester, a capacitor, converter(s), and a load.</li> <li>Modular architecture allows to integrate a variety of different models and datasets.</li> <li>Versatile logging possibilities.</li> <li>Support for small-scale simulations (e.g., arbitrary time resolution \\(\\leq 1\\mu s\\)) and long-term simulations (e.g., several weeks of real-world harvesting traces).</li> <li>Trade-off exploration tool that allows automatically run experiments and retrieve statistics, so to derive optimal parameters for a given application.</li> </ul>"},{"location":"#example-use-case","title":"Example Use Case","text":"<p>The following example highlights the dependencies between device components within battery-free systems based on an intermittently-powered device that employs reactive intermittent computing (also called just-in-time checkpointing).</p>"},{"location":"#intermittent-computing-ic","title":"Intermittent computing (IC)","text":"<p>If the incoming (i.e., harvested) current is smaller than the outgoing (i.e., load) current, the device cannot operate continuously, but intermittently. This means that the device repeatedly experiences power-failures and has to use state-retention mechanisms (i.e., checkpointing) to ensure eventual progress in its application. </p> <p>A reactive IC device does this by observing its capacitor voltage and triggering a state-saving operation just before a power failure (i.e., at a certain threshold \\(V_{Chkpt}\\)). After the save operation, the device turns off and waits until its capacitor is recharged (i.e., to a certain threshold \\(V_{High}\\)), turns on to restore its state and continues operating until a state-save operation is triggered again.</p>"},{"location":"#exploring-forward-progress-and-reactivity","title":"Exploring forward progress and reactivity","text":"<p>The behavior (and efficiency) of such devices can vary significantly and depends on the chosen checkpointing parameters (e.g., \\(V_{High}\\), \\(V_{Chkpt}\\), checkpoint size, ...), but also on the employed device components (e.g., energy harvester, capacitor). To quantify the performance of intermittent computing devices, the following metrics can be used:</p> <ul> <li>Forward progress (\\(FP\\)): Describes the time a device spends on useful work (i.e., computation) in relation to the total elapsed time (i.e., charging, checkpointing, ...).</li> <li>Unavailability (\\(t_{Unavailable}\\)): Describes the time in which a device is not responsive, i.e., because of recharging or checkpointing activities.</li> </ul> <p>Note that these metrics are competing with each other (the higher \\(FP\\), the higher \\(t_{Unavailable}\\)) and thus, depending on the application, an appropriate trade-off must be found. For example, sensing application might favor a small unavailability (e.g., to capture events), while computation-heavy applications might favor forward progress. \\(FP\\) and \\(t_{Unavailable}\\) are highly dependent on many device properties, including the capacitance and harvesting current.</p>"},{"location":"#simulation-example","title":"Simulation example","text":"<p>To showcase this behavior, we simulate such a reactive IC sensor node using different capacitances (\\(C\\)) and harvesting currents (\\(I_{in}\\)) and retrieve the \\(FP\\) and \\(t_{Unavailable}\\) for each configuration<sup>1</sup>.</p> <p> </p> Larger capacitances give a higher forward progress (due to smaller checkpointing overhead), but increase unavailability because of longer charging times. <p> </p> Forward progress and unavailability are further affected by the harvesting current (as well as load current), which must thus be considered carefully for any given application. <p>Simba allows to explore these dependencies and can help to verify whether designs can meet the application requirements. </p> <ol> <li> <p>This example is also available in the simulator repo under Simulations/sim_example_iin_capsize.py.\u00a0\u21a9</p> </li> </ol>"},{"location":"Description/Implementation%20details/","title":"Implementation details","text":""},{"location":"Description/Implementation%20details/#architecture","title":"Architecture","text":"<p>Simba features a modular architecture that allows to use and configure different component implementations in a plug-and-play manner, while using the same simulation core. The overall architecture is shown below and described in more detail in our paper.</p> <p></p>"},{"location":"Description/Implementation%20details/#implementation","title":"Implementation","text":"<p>The interactions and dependencies between the device components - as detailed in  Simulation principle - are accounted for in the main simulator class using the following procedure:        </p> <pre><code>Reset all modules to start condition\nt = 0\n\nFor each simulation step until t = tmax:\n\n    Vcap = f(Capacitor)\n\n    Voc = f(Harvester, t)\n    Vin = f(Converter, Vcap, Voc)\n    Iin = f(Harvester, t, Vin)\n    Ein = f(Converter, Vin, Iin)\n\n    Vout = f(Converter, Vcap)\n    Iout = f(Load, Vout, Vcap) \n    Eout = f(Converter, Vcap, Iout)\n    Iquiescent = f(Converter, Vcap)\n\n    Itotal = Iin * Vin / Vcap * Ein - Iout * Vout / Vcap / Eout - Iquiescent\n    dt = f(Converter, Load, Harvester)\n\n    Update Capacitor according to: f(Capacitor, Itotal, dt)\n    Update Harvester according to: f(Harvester, dt, Vin)    \n    Update Converter according to: f(Converter, dt, Vcap)\n    Update Load according to: f(Load, Vcap, Vout, dt)\n\n    t = t + max(t_min, min(dt, t_max))\n</code></pre> <p>The values required in the simulation core (<code>Vin</code>, <code>In</code>, etc.) are depending on the module implementation. The different modules (i.e., <code>Harvester</code>, <code>Converter</code>, <code>Load</code>, <code>Capacitor</code>) have to implement pre-defined interfaces, such that different module implementations can be selected and simulated in a plug-and-play manner, using the same underlying simulation principle. For more information on the module interfaces and their configuration, see Module implementations.</p> <p>Discrete time <code>t</code> and Timestep <code>dt</code></p> <p>Simba adopts a discrete-time simulation, i.e., the time <code>t</code> is represented in integer values, with a configurable, minimum timestep of <code>t_min</code> (the default value is \\(1 \\mu s\\).) </p> <p>To increase simulation speed, the timestep <code>dt</code> is variable for each simulation step and is commonly set to the time until the next event (i.e., state-change due to capacitor voltage) of any of the submodules: <code>dt_modules = f(Converter, Load, Harvester)</code>. Each module has to notify the simulation core at which point in time (if any), they expect the next change in their state. </p> <p>For example:</p> <ul> <li>The <code>Converter</code> state (<code>Ein, Eout, Vout, Vin</code>) can change if the capacitor voltage reaches certain thresholds.</li> <li>The <code>Load</code> state (<code>Iout</code>) can change depending on the implemented Load/Application over time (e.g., different tasks might exhibit different power consumptions).</li> <li>The <code>Harvester</code> state can change over time due to environmental changes (i.e., solar traces, temperature changes etc.), or if the capacitor voltage changes (i.e., I-V characteristics of certain harvesters).</li> </ul> <p>Additionally, to increase simulation accuracy, a maximum timestep <code>t_max</code> can be configured, to force a simulation round even before one the modules registered an update (i.e.,  <code>dt = min(t_max, dt_modules)</code>).</p>"},{"location":"Description/Implementation%20details/#logging-and-performance-metrics","title":"Logging and performance metrics","text":"<p>Logging. Simba's logging is performed on two layers:</p> <ul> <li>The simulation core can be instructed to log high-level information (i.e., any value that is used in the simulation core's algorithm above). This allows to easily compare different designs, regardless of the underlying device components (i.e., module implementations). To save storage space and speed up the simulations, the simulation core can be instructed to store only certain values (e.g., <code>log_keys = [&lt;VALUE_NAMES&gt;]</code> ) and only if certain values change (e.g., <code>log_triggers = [&lt;VALUE_NAMES&gt;]</code>).</li> <li>Each module implements its own logging functions, that is triggered within the module's <code>update_state</code> function and stores data along with a global timestamp. The data can be retrieved once the simulation has finished and can then be post-processed (i.e., merged). Using this structure, the level of detail of logging information is up to the module developer and can be easily extended if required. </li> </ul> <p>Performance metrics. Based on its stored logs, each module can further derive its own performance metrics which are made available to the Trade-off exploration tool. They are also implemented on a module implementation level, as these metrics can be highly application/module specific. For example, harvester modules might derive the actual and maximum available energy, while load modules can derive very detailed statistics such as the number of executed tasks, experienced power failures etc.</p>"},{"location":"Description/Module%20implementations/","title":"Module implementations","text":"<p>Module implementations describe the (real-world) hardware components (i.e., harvester, load, converter, or capacitor) and can - for example - contain simple mathematical representations of (ideal) components, complex analytical models, or  data sets from experimental campaigns. To define and use a certain module implementation, the module-specific interfaces have to be implemented and the desired module has to be configured accordingly.</p>"},{"location":"Description/Module%20implementations/#available-module-implementations","title":"Available module implementations","text":"<p>Simba provides a number of pre-defined module implementations which can be configured individually and thus already cover a large number of different battery-free systems.</p> Module ModuleTypes Harvesters Artificial, IVCurve, SolarPanel, TEG Converter Diode (converter-less), BuckBoost, LDO, BQ25570 Capacitor IdealCapacitor, TantulumCapacitor Load ConstantLoad, TaskLoad, JITLoad, JITLoadAdvanced"},{"location":"Description/Module%20implementations/#configuration","title":"Configuration","text":"<p>To select the desired module implementation, each module (i.e., Harvester, Converter, Capacitor etc.) can be configured using a dedicated configuration (file) in <code>.json</code> format as follows:</p> <pre><code>{\n\u00a0 \"type\": \"&lt;ModuleType&gt;\",\n\u00a0 \"settings\" : \"&lt;ModuleSettings&gt;\"\n}\n</code></pre> <p>&lt;ModuleType&gt; is the name of the subtype/implementation of the module and &lt;ModuleSettings&gt; \u00a0contain module-specific settings. For module-specific settings, check out the description of each module implementation.</p>"},{"location":"Description/Module%20implementations/#module-interfaces","title":"Module interfaces","text":"<p>In order to create a new Simba-compatible module implementation, a number of methods have to implemented accordingly. This include common methods that are called for all modules (e.g., <code>reset</code>, <code>update_state</code> etc.) and module-specific methods that are only required for a certain type of module (e.g., <code>get_input_efficiency</code> is certainly only required for the converter module).</p> <p>In the following, we briefly describe the mandatory common and module-specific methods for each module type.</p>"},{"location":"Description/Module%20implementations/#common-methods","title":"Common methods","text":"<ul> <li><code>reset()</code>: Initialize the module (e.g., load required data, set up variables) and set initial state.</li> <li><code>update_state()</code>: Update the module's internal state and log data if required - for more module-specific information, see below.</li> <li><code>process_log()</code>: Called at the end of the simulation to process logging data from module implementation (if required).</li> <li><code>get_log()</code>: Retrieve (detailed) logging data from module implementation as Pandas <code>DataFrame</code> datatype.</li> <li><code>get_stats()</code>: Derive module-specific statistics from logging data and provide this data as a <code>dict</code> data type (for more details, refer to Trade-off exploration).</li> <li><code>get_next_change()</code>: Inform the simulation core of the next expected update within the module (i.e., returns the time until next update in seconds)  - for more module-specific information, see below.</li> </ul>"},{"location":"Description/Module%20implementations/#harvester-specific-methods","title":"Harvester-specific methods","text":"<p>The <code>Harvester</code> modules represent energy sources that supply the sensor node with incoming power.</p> <p>Common methods</p> <ul> <li><code>update_state(time, dt, v_in)</code>: Update state if necessary (i.e., if environmental conditions have changed and a different harvesting current applies) and log (actual and maximal) harvesting current and applied voltage at given time.</li> <li><code>get_next_change(time)</code>: Inform the simulation core when the harvesting conditions change.</li> </ul> <p>Harvester-specific methods (mandatory)</p> <ul> <li><code>get_current(time, v_in)</code>: Return the harvesting current (in A) at the specified voltage at the current time.</li> <li><code>get_ocv(time)</code>: Return open-circuit voltage of harvester at the current time.</li> </ul> <p>Harvester-specific methods (optional)</p> <ul> <li><code>plot_iv_curve()</code>, <code>plot_irradiance()</code>, <code>...</code> : Harvester-specific plot functions to support users while using Simba.</li> </ul>"},{"location":"Description/Module%20implementations/#converter-specific-methods","title":"Converter-specific methods","text":"<p>The <code>Converter</code> modules represent the voltage converter(s) between harvester and capacitors (\"<code>input</code>\") as well as capacitor and load (\"<code>output</code>\").</p> <p>Common methods</p> <ul> <li><code>update_state(time, dt, cap_voltage)</code>: Update state if necessary (i.e., turn-on/turn-off thresholds have been reached) and log converter-specific values (e.g., efficiencies, quiescent current, state) at given time.</li> <li><code>get_next_change(time)</code>: Inform the simulation core when the converter changes its state (e.g., when the next MPP sampling takes place).</li> </ul> <p>Converter-specific methods (mandatory)</p> <ul> <li><code>get_input_operating_voltage(v_cap)</code>: Return (operating) voltage of converter between harvester and capacitor.</li> <li><code>get_input_efficiency(v_cap, i_in)</code>: Return efficiency of converter between  harvester and capacitor.</li> <li><code>get_output_operating_voltage(v_cap)</code>: Return output voltage of converter between capacitor and load.</li> <li><code>get_output_efficiency(v_cap, i_out)</code>: Return efficiency of converter between capacitor and load.</li> <li><code>get_quiescent(v_cap)</code>: Return quiescent current (in A) depending on voltage level.</li> <li><code>get_next_threshold(v_cap, i_total)</code>: If any, return the next voltage threshold at which the converter will change its state.</li> </ul>"},{"location":"Description/Module%20implementations/#capacitor-specific-methods","title":"Capacitor-specific methods","text":"<p>The <code>Capacitor</code> modules describe the energy buffer between harvester and load.</p> <p>Common methods</p> <ul> <li><code>update_state(time, dt, i_total)</code>: Update the capacitor's state (i.e., state of charge) according to the current flow and the capacitor's leakage and log capacitor voltage (and leakage) at the given time.</li> <li><code>get_next_change(i_total, voltage_threshold)</code>: Inform the simulation core when the given voltage threshold (e.g., supplied by the load or converter) would be reached, given the actual current.</li> </ul> <p>Capacitor-specific methods (mandatory)</p> <ul> <li><code>get_voltage()</code>: Provide the current voltage of the capacitor.</li> </ul>"},{"location":"Description/Module%20implementations/#load-specific-methods","title":"Load-specific methods","text":"<p>The <code>Load</code> modules represent the load (e.g., sensor node) to be powered by the harvester and capacitor. Note that the load module must include/model the power consumption of both the MCU and any peripherals attached to it.</p> <p>Common methods</p> <ul> <li><code>update_state(time, dt, v_out, v_cap)</code>: Update the load's internal state (e.g., currently running task etc.) accordingly and log any load-specific values (e.g., state, voltages, current consumption) at the given time.</li> <li><code>get_next_change(time)</code>: Inform the simulation core when the load changes its state (e.g., when the next task is scheduled).</li> <li><code>get_next_threshold(v_cap, i_total)</code>: If any, return the next voltage threshold at which the load will change its state.</li> </ul> <p>Load-specific methods (mandatory)</p> <ul> <li><code>get_current(v_out)</code>: Return the load's current consumption in the current state.</li> <li><code>get_state()</code>: Return the load's current internal state (for logging purposes only).</li> </ul>"},{"location":"Description/Simulation%20principle/","title":"Simulation principle","text":"<p>Simba allows to simulate the behavior of a battery-free sensor node that consists of</p> <ul> <li>an energy harvester</li> <li>a converter</li> <li>an energy buffer (capacitor)</li> <li>a load (e.g., MCU and sensors)</li> </ul> <p>Simba accounts for any energy-related dependencies between these sensor node components (as sketched below) using fixed interfaces. This allows to plug in different implementations/models/data set for each component and thus a variety of different battery-free systems can be simulated, investigated, and compared using the very same simulation core.</p> <p></p> <p>System model and simulation principle. Simba adopts a time-discrete simulation of the sensor node sketched above. More specifically, at every time-step \\(T\\) (of variable length), the simulation core monitors, updates, and logs each module's state accordingly. </p> <p>The simulation procedure is centered around the capacitor's energy state, where its current-voltage relation is defined as</p> <p>\\(V_{cap} = {1 \\over C} \\int_{t_0}^{t_0 + T} I_{cap}(t) \\,dt + V_{cap}(t_0)\\).</p> <p>\\(I_{cap}(t)\\) is the instantaneous current flowing into or out of the capacitor and is assumed to be constant within \\(dt\\). More specifically, this current flow is depending on the incoming energy from the harvester (i.e., harvested current \\(I_{in}\\)) and the power consumption of the load (i.e., given by \\(I_{out}\\)). Furthermore, also other modules have a large impact on the actual current draw, such as the capacitor's leakage current (\\(I_{leak}\\)), or - if a converter is applied - the converter's quiescent currents  (\\(I_{quiescent}\\)) and efficiencies (\\(n_{OUT}\\), \\(n_{IN}\\)).</p> <p>In summary, \\(I_{cap}(t)\\) can be given by: \\(I_{cap}(t) = I_{cap,in}(t) - I_{cap,out}(t) - I_{leak} - I_{quiescent}\\).</p> <p>Note that the derivation of these components (\\(I_{cap,in}, I_{cap,out},n_{IN}\\) etc.) is not straight-forward, as there exist large dependencies between the modules, as described in more detail below.</p> <p>Incoming current: \\(I_{cap,in} = I_{in} * \\frac{V_{in}}{V_{cap}} * n_{in}\\)</p> <p>The incoming current \\(I_{cap,in}\\) certainly depends on the employed energy harvester and changes over time due to environmental conditions. Moreover, most harvesters exhibit a distinct, non-linear I-V characteristics and thus the harvester's current depends on the harvester's operating voltage (and vice versa). Depending on the employed converter, the harvester's operating voltage can be either i) directly coupled to the capacitor voltage (i.e., in case of a diode) or ii) be set to a certain voltage level so to operate the harvester at the optimal operating point (i.e., using converter chips that implement maximum power point tracking (MPPT) techniques). If no converter is used, the harvesting voltage and capacitor voltage is equal, hence the harvesting current can also directly charge the capacitor (\\(I_{cap,in} = I_{in}\\)). In converter-based systems, however, there is a strong interaction between capacitor voltage \\(V_{cap}\\), harvesting current \\(I_{in}\\) and voltage \\(V_{in}\\), and the converter's conversion efficiency \\(n_{in}\\) that has to be considered.</p> <p>Outgoing current: \\(I_{cap,out} = I_{out} * \\frac{V_{out}}{V_{cap}} * \\frac{1}{E_{out}}\\)</p> <p>The outgoing current \\(I_{out}\\) is mainly defined by the power consumption of the load and thus on the application it is running. Note, however, that the application itself can depend on the capacitor voltage \\(V_{cap}\\) (and thus implicitly on the incoming current). For example, reactive intermittent systems create/restore system checkpoints and turn itself on/off depending on the capacitor's voltage level. The time the device spends operating and does useful work (i.e., the so-called forward progress) thus highly depends on the storage capacity and the incoming energy. </p> <p>Furthermore, the converter architecture has a significant impact on the load's power consumption. In converter-less sytems (i.e., if the load is directly coupled to the capacitor), the operating voltage of the load decreases as the capacitor gets depleted and thus the power consumption changes over time even if the application remains in the same state. In converter-based systems, the voltage and thus the power consumption remains constant under a given \\(I_{out}\\), but has to be compensated by the converter efficiency \\(n_{out}\\). </p> <p>Other currents </p> <p>Other contributors to the outgoing current are the system's (e.g., converter's) quiescent current \\(I_{quiescent}\\) and the leakage current \\(I_{leak}\\) of the employed capacitor (e.g, due to self-discharge).</p>"},{"location":"Description/Trade-off%20exploration/","title":"Trade off exploration","text":"<p>The trade-off exploration tool - as shown below - allows to automatically run simulations in a certain (user-defined) design space and retrieves the requested performance metrics from the module's logs. </p> <p></p> <p>More specifically, the users specifies:</p> <ul> <li>a base configuration (of each module) </li> <li>an arbitrary number of design parameters (of any module) to explore<sup>1</sup> </li> <li>an arbitrary number of performance metrics (of any module) to retrieve<sup>1</sup> </li> </ul> <p>The trade-off exploration tool then </p> <ul> <li>permutes the specified parameters</li> <li>sets up the simulation core accordingly</li> <li>runs all the simulations concurrently (i.e., using multiprocessing, to speed up the exploration process)</li> <li>retrieves the requested performance metrics and provides them to the user</li> </ul>"},{"location":"Description/Trade-off%20exploration/#example","title":"Example","text":"<p>In this example, the number of successful checkpoints is retrieved for different settings of the checkpointing voltage threshold and capacitances<sup>1</sup>.</p> <pre><code>base_config = {'harvester' : harvest_config,\n                'load' : load_config,\n                'capacitor' : capacitor_config,\n                'converter' : converter_config,\n                'sim_time' : 10}\n\nparams = {'load.v_checkpoint' : list(np.arange(3.3, vhigh, 0.01)),\n          'cap.capacitance : [3300e-6, 5100e-6]'}\n\nmetrics = [{'module' : 'load', 'params' : ['num_CHECKPOINT_successful']}]\n\nresult = run_tradeoff_exploration(params, metrics, base_config)\n</code></pre> <ol> <li> <p>For more details, refer to the paper and the simulation in Simulations/get_gameboy_checkpoint_threshold.py.\u00a0\u21a9\u21a9\u21a9</p> </li> </ol>"},{"location":"Module%20implementations/Capacitors/IdealCapacitor/","title":"IdealCapacitor","text":""},{"location":"Module%20implementations/Capacitors/IdealCapacitor/#description","title":"Description","text":"<p>The <code>IdealCapacitor</code> module describes an ideal capacitor (i.e., with no leakage) with a certain capacitance and voltage rating.</p>"},{"location":"Module%20implementations/Capacitors/IdealCapacitor/#parameters","title":"Parameters","text":"Parameter man./opt. Value Description <code>capacitance</code> m Capacitance in F <code>v_rated</code> m Max. rated voltage in V To log \u2018overvoltage\u2019 alarm <code>v_initial</code> o Voltage in V Voltage at start of sim. (Default: 0)"},{"location":"Module%20implementations/Capacitors/IdealCapacitor/#example-configurations","title":"Example configuration(s)","text":"<pre><code>cap_config = {\n    'type' :  'Ideal',\n    'settings' : {'capacitance' : 10e-6,\n                  'v_rated' : 10}\n    }\n</code></pre>"},{"location":"Module%20implementations/Capacitors/TantulumCapacitor/","title":"TantulumCapacitor","text":""},{"location":"Module%20implementations/Capacitors/TantulumCapacitor/#description","title":"Description","text":"<p>The <code>TantulumCapacitor</code> module describes a capacitor of the AVX TAJ series with a certain capacitance and voltage ratings. In contrast to an ideal capacitor, tantulum capacitors exhibit leakage currents that depend on (i) the capacitance, (ii) the rated voltage, and (iii) the applied voltage. This behavior is modelled according to the AVX technical notes and accounted for in the charge/discharge behavior of the capacitor.</p> <p>For more details on the leakage modeling, see: </p> <ul> <li>Low Leakage Current Aspect of Designing with  Tantalum and Niobium Oxide Capacitors: https://www.avx.com/docs/techinfo/Low_Leakage_Current_Aspect_Designing_Tantalum_Niobium_Oxide_Capacitors.pdf).</li> <li>Jie Zhan et al. Exploring the Effect of Energy Storage Sizing on Intermittent Computing System Performance. IEEE Trans. on Computer-Aided Design of Integrated Circuits and Systems (2022).</li> </ul>"},{"location":"Module%20implementations/Capacitors/TantulumCapacitor/#parameters","title":"Parameters","text":"Parameter man./opt. Value Description <code>capacitance</code> m Capacitance in F <code>v_rated</code> m Max. rated voltage in V To log \u2018overvoltage\u2019 alarm <code>v_initial</code> o Voltage in V Voltage at start of sim. (Default: 0)"},{"location":"Module%20implementations/Capacitors/TantulumCapacitor/#example-configurations","title":"Example configuration(s)","text":"<pre><code>cap_config = {\n    'type' :  'Tantulum',\n    'settings' : {'capacitance' : 10e-6,\n                  'v_rated' : 10,\n                  'v_initial' : 3.3}\n    }\n</code></pre>"},{"location":"Module%20implementations/Converters/BQ25570/","title":"BQ25570","text":""},{"location":"Module%20implementations/Converters/BQ25570/#description","title":"Description","text":"<p>The <code>BQ25570</code> module models the TI BQ25570 ultra-low power energy harvesting chip. The BQ25570 embeds a boost charger and MPPT logic, that allows to efficiently extract energy from low-power energy harvesters (from voltages as low as 100 mV). It further offers a buck converter to provide a constant (programmable) output power to the load and provides a hysteresis behavior using its \"Battery-Good Output Flag\" to turn on/off the output at specific voltage thresholds.</p> <p>This model embeds look-up tables of the converter's efficiencies at different operating points and input/output currents along with the IC's quiescent current and implements the chip's MPPT mechanism (i.e., <code>Vin</code> = MPP_ratio * open-circuit voltage).  </p>"},{"location":"Module%20implementations/Converters/BQ25570/#parameters","title":"Parameters","text":"Parameter man./opt. Value Description <code>v_out</code> m Voltage in V Output voltage of buck converter, available options: <code>v_ov</code> m Voltage in V Over-voltage threshold <code>mpp</code> m (0...1) MPP ratio to set input voltage accordingly (i.e., <code>Vin = MPP_ratio * Voc</code>) <code>vout_ok_enable</code> o Boolean Define whether hysteresis behavior should apply (Default: <code>False</code>) <code>vout_ok_high</code> o* Voltage in V VBAT_OK_HYST  threshold (turn-on threshold) <code>vout_ok_low</code> o* Voltage in V VBAT_OK threshold (turn-off threshold) <code>log</code> o Boolean Define whether logging is enabled (Default: <code>False</code>) *mandatory of <code>vout_ok_enable</code>"},{"location":"Module%20implementations/Converters/BQ25570/#example-configurations","title":"Example configuration(s)","text":"<pre><code>converter_config = {\n\u00a0 \u00a0 'type' : 'BQ25570',\n\u00a0 \u00a0 'settings' : {'v_ov' : 5,\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'v_out' : 3.0,\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'vout_ok_high' : 4,\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'vout_ok_low' : 3.3,\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'vout_ok_enable' : True,\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'mpp' : 0.8,\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'log' : True\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 }}\n</code></pre>"},{"location":"Module%20implementations/Converters/BuckBoost/","title":"BuckBoost","text":""},{"location":"Module%20implementations/Converters/BuckBoost/#description","title":"Description","text":"<p>The <code>BuckBoost</code> module describes a converter structure, where the boost- and buck-converter stages can be configured arbitrarily. For both converters, the voltage and efficiencies can be set accordingly. If the input/output voltage is not configured or set to zero, it is assumed that no converter is used (e.g., <code>Vout = Vcap</code> + <code>Eout = 1</code> or <code>Vin = Vcap</code>+ <code>Ein = 1</code>).</p> <p>This model also implements an overvoltage protection of the capacitor, i.e., the input efficiency is set to 0 if <code>VCap</code> &gt; <code>v_ov</code>, and the quiescent current of the converter(s) can be configured.</p>"},{"location":"Module%20implementations/Converters/BuckBoost/#parameters","title":"Parameters","text":"Parameter man./opt. Value Description <code>v_out</code> o Voltage in V Output voltage of buck converter (if <code>v_out &gt; 0</code>, else <code>Vout = VCap</code>) (Default: 0) <code>v_in</code> o Voltage in V Output voltage of boost converter (if <code>v_in &gt; 0</code>, else <code>Vin = VCap</code>) (Default: 0) <code>efficiency_out</code> o (0 ... 1) Efficiency of buck converter (Default: 1) <code>efficiency_in</code> o (0 ... 1) Efficiency of boost converter  (Default: 1) <code>v_ov</code> m Voltage in V Over-voltage threshold <code>i_quiescent</code> o Current in A Quiescent current of converter (Default: 0)"},{"location":"Module%20implementations/Converters/BuckBoost/#example-configurations","title":"Example configuration(s)","text":"<pre><code>config_buck_only = {\n     'type' : 'BuckBoost',\n     'settings' : {'v_out' : 2.0, \u00a0\n                   'v_in' : 0, \u00a0# or omit entirely, v_in is set to v_cap\n                   'efficiency_out' : \u00a00.8, \u00a0 \n                   'efficiency_in' : 1, # or omit entirely, Ein is set to 1\n                   'v_ov' : 5.0,\n                   'i_quiescent' : 1e-6}},\n\nconfig_boost_only = {\n     'type' : 'BuckBoost',\n     'settings' : {'v_out' : 0, \u00a0# or omit entirely, v_out is set to v_cap\n                   'v_in' : 1.5, \n                   'efficiency_out' : 1, # or omit entirely, Eout is set to 1\n                   'efficiency_in' :\u00a00.6, \u00a0 \n                   'v_ov' : 5.0,\n                   'i_quiescent' : 1e-6}},\n\nconfig_buck_boost = {\n     'type' : 'BuckBoost',\n     'settings' : {'v_out' : 2.0, \u00a0\n                   'v_in' : 1.5, \n                   'efficiency_out' : 0.8,\n                   'efficiency_in' : 0.6, \u00a0 \n                   'v_ov' : 5.0,\n                   'i_quiescent' : 1e-6}},\n</code></pre>"},{"location":"Module%20implementations/Converters/Diode%20%28converter-less%29/","title":"Diode (converter less)","text":""},{"location":"Module%20implementations/Converters/Diode%20%28converter-less%29/#description","title":"Description","text":"<p>The <code>Diode</code> module describes an (ideal) converter-less node architecture where energy harvester, capacitor, and load are directly coupled (i.e., <code>Vin = Vcap</code> and <code>Vout = Vcap</code>). Typically, a diode is used in this settings to avoid a backfeeding of the capacitor's energy to the harvester. Note that in this model, no diode voltage drop is considered. This model also implements an overvoltage protection of the capacitor, i.e., the input efficiency is set to 0 if <code>Vcap</code> &gt; <code>v_ov</code>. Otherwise, the input/output efficiencies are set to 100% and no losses are considered (<code>Ein = Eout = 1</code>, <code>i_quiescent = 0</code>).</p>"},{"location":"Module%20implementations/Converters/Diode%20%28converter-less%29/#parameters","title":"Parameters","text":"Parameter man./opt. Value Description <code>v_ov</code> m Voltage in V Overvoltage protection"},{"location":"Module%20implementations/Converters/Diode%20%28converter-less%29/#example-configurations","title":"Example configuration(s)","text":"<pre><code>converter_config = {\n    'type' : 'Diode',\n    'settings' : {'v_ov' : 3.3}\n    }\n</code></pre>"},{"location":"Module%20implementations/Converters/LDO/","title":"LDO","text":""},{"location":"Module%20implementations/Converters/LDO/#description","title":"Description","text":"<p>The <code>LDO</code> module describes a converter structure, where a linear low-dropout regulator is placed between capacitor and load to convert the capacitor voltage to a fixed output voltage (i.e., <code>Vout = X</code>) by dissipating the difference between input/output voltage as waste heat (i.e., <code>Eout = Vout/Vcap</code>). In this configuration, there is no converter between harvester and capacitor (i.e., <code>Vin = Vcap</code>, <code>Ein = 1</code>). </p> <p>Additionally, this converter module can optionally model a hysteresis behavior, where the output is switched on/off at pre-defined voltage thresholds.</p>"},{"location":"Module%20implementations/Converters/LDO/#parameters","title":"Parameters","text":"Parameter man./opt. Value Description <code>v_out</code> m Voltage in V Output voltage of LDO <code>i_quiescent</code> o Current in A Quiescent current if output enabled (Default: 0) <code>i_quiescent_off</code> o Voltage in V Quiescent current if output disabled (Default: <code>i_quiescent</code>) <code>enable_hyst</code> o Boolean Define whether hysteresis behavior should apply (Default: <code>False</code>) <code>v_high</code> o* Voltage in V Turn-on  hysteresis threshold <code>v_low</code> o* Voltage in V Turn-off  hysteresis threshold *Mandatory if <code>enable_hyst = True</code>"},{"location":"Module%20implementations/Converters/LDO/#example-configurations","title":"Example configuration(s)","text":"<pre><code>converter_config = {\n 'type' : 'LDO',\n 'settings' : {'v_out' : \u00a02.2, \u00a0\n               'v_high' : 3.1, \u00a0\n               'v_low' : \u00a02.4, \u00a0 \n               'enable_hyst' : True,\n               'i_quiescent' : \u00a0 \u00a0 1e-6}}\n</code></pre>"},{"location":"Module%20implementations/Harvesters/Artificial/","title":"Artificial","text":""},{"location":"Module%20implementations/Harvesters/Artificial/#description","title":"Description","text":"<p>The <code>Artificial</code> energy source can supply current either constantly or as a sine/square wave (more waveforms can be implemented on demand) with adjustable current amplitude and duty cycle.</p>"},{"location":"Module%20implementations/Harvesters/Artificial/#parameters","title":"Parameters","text":"Parameter man./opt. Value Description <code>shape</code> m <code>const</code>, <code>square</code>, <code>sine</code> Either constant current, square wave (repeating i_high for t_high and t_high for t_low), or sine wave (with a period of period and an amplitude between 0 and i_high) <code>i_high</code> m Current in A Constant current value (<code>const</code>), value of high phase (<code>square</code>), amplitude (<code>sine</code>) <code>i_low</code> m* Current in A Value of low phase (<code>square</code> only) <code>t_high</code> m* Time in seconds Length of high phase (<code>square</code> only) <code>t_low</code> m* Time in seconds Length of low phase (<code>square</code> only) <code>period</code> m** Time in seconds Period of sine wave (<code>sine</code> only) <code>log</code> o Boolean Define whether logging is enabled (Default: <code>False</code>) <p>*Mandatory for <code>square</code> shape ** Mandatory for <code>sine</code> shape</p>"},{"location":"Module%20implementations/Harvesters/Artificial/#example-configurations","title":"Example configuration(s)","text":"<pre><code>harvest_config_const = {\n    'type' :  'Artificial',\n    'settings' : {'shape' : 'const',\n                  'i_high' : 400e-6}\n    }\n\nharvest_config_square = {\n    'type' :  'Artificial',\n    'settings' : {'shape' : 'square',\n                  'i_high' : 400e-6,\n                  'i_low' : 0,\n                  't_high' : 100e-6,\n                  't_low' : 100e-6}\n    }\n\nharvest_config_sine = {\n    'type' :  'Artificial',\n    'settings' : {'shape' : 'sine',\n                  'i_high' : 400e-6,\n                  'period' : 100e-3}\n    }\n</code></pre>"},{"location":"Module%20implementations/Harvesters/IVCurve/","title":"IVCurve","text":""},{"location":"Module%20implementations/Harvesters/IVCurve/#description","title":"Description","text":"<p>The <code>IVCurve</code> module contains the IV curve of a energy harvester at the certain environmental condition (e.g., for solar panel this means a single IV-curve at a certain brightness). This module thus allows to incorporate the non-linear behavior of many harvesters into the simulation. </p> <p>The IV-curves are stored in Harvesters/harvesting_data/IVCurves as <code>.json</code>-Files. To add new IV-Curves, see Tools/get_iv_curve_XXXX.py and the corresponding Readme.</p>"},{"location":"Module%20implementations/Harvesters/IVCurve/#parameters","title":"Parameters","text":"Parameter man./opt. Value Description <code>file</code> m Filename Filename of <code>.json</code>-File that contains the IV curve data. <code>log</code> o Boolean Define whether logging is enabled (Default: <code>False</code>)"},{"location":"Module%20implementations/Harvesters/IVCurve/#example-configurations","title":"Example configuration(s)","text":"<pre><code>harvest_config = {  'type' \u00a0 \u00a0 \u00a0 : 'IVCurve',\n                    'settings' \u00a0 : {'file' \u00a0 \u00a0 \u00a0 : 'KXOB25-02-X8F_lux20000.json',\n                                    'log' : LOG\n                                    }}\n</code></pre>"},{"location":"Module%20implementations/Harvesters/SolarPanel/","title":"SolarPanel","text":""},{"location":"Module%20implementations/Harvesters/SolarPanel/#description","title":"Description","text":"<p>The <code>SolarPanel</code> module allows to use long-term real-world solar energy harvesting traces in simulation, by including - a PV cell model that can be configured according to parameters that are typically available in datasheets, and - real-world solar irradiance traces from existing datasets (e.g., NREL for outdoor and ENHANTS for indoor environments).</p> <p>Examples for solar irradiance traces and their format can be found in Harvesters/harvesting_data/SolarTraces/DATASET. They can be extended with additional custom traces or with traces downloaded from the mentioned datasets (see Readmes in the corresponding folders).</p>"},{"location":"Module%20implementations/Harvesters/SolarPanel/#parameters","title":"Parameters","text":"Parameter man./opt. Value Description <code>file</code> m Filename Filename of <code>.json</code>-File that contains the solar irradiation trace (e.g., DATASET/trace.json) <code>t_start</code> o Time in seconds Start time of harvesting trace for simulation (to cut beginning of full trace) (Default: 0) <code>t_max</code> o Time in seconds Total time of harvesting trace for simulation (to cut end of full trace and limit amount of stored data during simulation) (Default: max. trace length) <code>i_sc</code> m Current in A Short circuit current of solar panel (or single cell) at 1000 W/m2 <code>v_oc</code> m Voltage in V Open circuit voltage of solar panel (or single cell) at 1000 W/m2 <code>i_mpp</code> m Current in A Current at MPP at 1000 W/m2 <code>v_mpp</code> m Voltage in V Voltage at MPP at 1000 W/m2 <code>num_cells</code> o Integer Number of PV cells in solar panel (Default: 1) <code>connection</code> o* \"parallel\" or \"series\" Define how the PV cells are connected <code>log</code> o Boolean Define whether logging is enabled (Default: <code>False</code>) <p>* mandatory if <code>num_cells &gt; 1</code> </p>"},{"location":"Module%20implementations/Harvesters/SolarPanel/#example-configurations","title":"Example configuration(s)","text":"<pre><code>harvest_config = {'type' \u00a0 \u00a0 \u00a0 : 'SolarPanel',\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'settings' \u00a0 : {'file' \u00a0 \u00a0 \u00a0 : 'NREL/2023jun.json',\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0'i_sc' : 14.8e-3,\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0'v_oc' : 3.56,\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0'v_mpp': 2.6,\n\u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0'i_mpp': 12.1e-3,\n\u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0'log' : True\n\u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}}\n\nharvest_config = {'type' \u00a0 \u00a0 \u00a0 : 'SolarPanel',\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'settings' \u00a0 : {'file' \u00a0 \u00a0 \u00a0 : 'NREL/2023jun.json',\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0'i_sc' : 14.8e-3,\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0'v_oc' : 3.56,\n \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0'v_mpp': 2.6,\n\u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0'i_mpp': 12.1e-3,\n\u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0'num_cells' : 2,\n\u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0'connection' : 'parallel'\n\u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0'log' : True\n\u00a0 \u00a0 \u00a0\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0}}\n</code></pre>"},{"location":"Module%20implementations/Harvesters/TEG/","title":"TEG","text":""},{"location":"Module%20implementations/Harvesters/TEG/#description","title":"Description","text":"<p>The <code>TEG</code> module ...</p> <p>Warning</p> <p>TODO: Implemented, but documentation missing.</p>"},{"location":"Module%20implementations/Loads/ConstantLoad/","title":"ConstantLoad","text":""},{"location":"Module%20implementations/Loads/ConstantLoad/#description","title":"Description","text":"<p>The <code>ConstantLoad</code> module represents a load that draws a constant current (if any voltage is applied).</p>"},{"location":"Module%20implementations/Loads/ConstantLoad/#parameters","title":"Parameters","text":"Parameter man./opt. Value Description <code>current</code> m Current in A Current consumption of load <code>log</code> o Boolean Define whether logging is enabled (Default: <code>False</code>)"},{"location":"Module%20implementations/Loads/ConstantLoad/#example-configurations","title":"Example configuration(s)","text":"<pre><code>load_config = {\n    'type' :  'ConstantLoad',\n    'settings' : {'current' : '1e-3'}\n    }\n</code></pre>"},{"location":"Module%20implementations/Loads/JITLoad/","title":"JITLoad","text":""},{"location":"Module%20implementations/Loads/JITLoad/#description","title":"Description","text":"<p>The <code>JITLoad</code> module describes a load that uses a Just-In-Time checkpointing (JIT) approach to operate in the presence of power-failures (i.e., intermittently) according to the implementation in this paper. The device starts performs periodic checkpointing (with a specific period, length, and current consumption), once the capacitor voltage passes a certain threshold (\\(V_{Chkpt}\\)), turns off at \\(V_{OFF}\\) and restores the checkpoints after recharging to \\(V_{ON}\\) (with a specific period, length, and current consumption). In between, while computing, the device consumes a configurable constant current.</p> <p></p>"},{"location":"Module%20implementations/Loads/JITLoad/#parameters","title":"Parameters","text":"Parameter man./opt. Value Description <code>currents</code> m List of current consumptions in A Map of current consumptions corresponding to each state, using the following format: <code>t_checkpoint</code> m Time in s Duration of checkpoint operation <code>t_checkpoint_period</code> m Time in s Period of checkpoint operation <code>t_restore</code> m Time in s Duration of restore operation <code>t_restore_startup</code> m Time in s Duration of first restore operation after boot <code>v_checkpoint</code> m Voltage in V Checkpoint voltage threshold to start checkpointing once the capacitor voltage goes below this value <code>v_on</code> m Voltage in V Turn-on threshold to enter restore operation once the capacitor voltage exceeds this value <code>v_off</code> m Voltage in V Turn-off threshold to disable load once the load voltage goes below this voltage (i.e., minimum operating voltage) <code>log</code> o Boolean Define whether normal logging (i.e., only if any state change happens) is enabled (Default: <code>False</code>) <code>verbose_log</code> o Boolean Define whether verbose logging  (i.e., at each update call) is enabled (Default: <code>False</code>, can be enabled for smooth plotting)"},{"location":"Module%20implementations/Loads/JITLoad/#example-configurations","title":"Example configuration(s)","text":"<pre><code>load_config = {\n    'type' : 'JITLoad',\n    'name' : 'Battery-free Gameboy',\n    'settings' : {  'currents' : {   'RESTORE' : 2.65e-3*0.97,\n                                     'COMPUTE' : 3.28e-3*0.97,\n                                     'CHECKPOINT' : 2.87e-3*0.97},\n                    't_checkpoint' : 33e-3,\n                    't_checkpoint_period' : 270e-3,\n                    't_restore' : 255e-3,\n                    't_restore_startup' : 255e-3,\n                    'v_on' : 2.9,\n                    'v_off' : 2.8,\n                    'v_checkpoint' : 3.4,\n                    'log' : True}\n    }\n</code></pre>"},{"location":"Module%20implementations/Loads/JITLoadAdvanced/","title":"JITLoadAdvanced","text":"<p>Warning</p> <p>TODO: Implemented, but documentation missing.</p>"},{"location":"Module%20implementations/Loads/TaskLoad/","title":"TaskLoad","text":""},{"location":"Module%20implementations/Loads/TaskLoad/#description","title":"Description","text":"<p>The <code>TaskLoad</code> module describes a load that runs several tasks in a round-robin fashion (see Figure below). The tasks, their length, as well as their power consumption can be configured arbitrarily. As they can be modelled as fine-grained as required, the <code>TaskLoad</code> module allows to cover a wide range of different sensor node applications. The load further has a minimum operating voltage that is implemented as a hysteresis.</p> <p></p>"},{"location":"Module%20implementations/Loads/TaskLoad/#parameters","title":"Parameters","text":"Parameter man./opt. Value Description <code>tasks</code> m List of tasks List of tasks that should be executed in round-robin fashion, using the following format: <code>skip_initial_task</code> o Integer (0...NumTasks) Define whether the first n tasks in the list should be skipped in the round-robin scheduling (i.e., only execute them once after re-boot) (Default: 0) <code>v_on</code> m Voltage in V Min. operating voltage (turn-on threshold) <code>v_off</code> m Voltage in V Min. operating voltage (turn-off threshold) <code>i_off</code> m Current in A Current consumption if load is turned off <code>shutdown_after_completion</code> o Boolean Define whether device should turn itself off (i.e., instruct the converter to disable the supply voltage) after all tasks are completed (Default: <code>False</code>) <code>log</code> o Boolean Define whether normal logging (i.e., only if any state change happens) is enabled (Default: <code>False</code>) <code>verbose_log</code> o Boolean Define whether verbose logging  (i.e., at each update call) is enabled (Default: <code>False</code>, can be enabled for smooth plotting)"},{"location":"Module%20implementations/Loads/TaskLoad/#example-configurations","title":"Example configuration(s)","text":"<pre><code>load_config = {\n\u00a0 \u00a0 'type' : 'TaskLoad',\n\u00a0 \u00a0 'settings' : { 'tasks' : [{'name': 'INIT', \u00a0't' : 2e-3, \u00a0 'i': 600e-6},\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {'name': 'TASK1', 't' : 10e-3, \u00a0'i': 2000e-6},\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 {'name': 'TASK2', 't' : 100e-3, 'i': 500e-6}],\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'skip_initial_task' : 1,\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'v_on' : 1.9,\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'v_off' : 1.8,\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'i_off' : 1e-6,\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 'log' : True}\n\u00a0 \u00a0 }\n</code></pre>"}]}